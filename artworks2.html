<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Artworks - 한과 흥, 그리고 정</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.8.0/addons/p5.sound.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/shader-park-core/dist/shader-park-p5.js"></script>
  <script src="shaderParkCode.js"></script>
  <script src="artworks2.js"></script>
</head>


<body>
  <header class="header">
    <a href="index.html" class="logo-link">
      <img src="Assets/images/logo.svg" alt="느루" class="header-logo">
    </a>

    <nav class="nav">
      <ul>
        <li><a href="artworks1.html" style="color: var(--text-main)">작품목록</a></li>
        <li><a href="gallery.html">사진첩</a></li>
        <li><a href="about.html">소개</a></li>
      </ul>
    </nav>
  </header>

  <div class="sub-header">
    <div class="toggle-container">
      <a href="artworks1.html" class="toggle-btn">한 恨</a>
      <a href="artworks2.html" class="toggle-btn active">흥 興</a>
    </div>
  </div>

  <main class="inner-container">
    <h2 class="page-title">Part 2<br>– 정의 회복, 흥</h2>

    <div class="audio-wrapper">
      <audio controls controlsList="nodownload" oncontextmenu="return false" class="custom-audio">
        <source src="Assets/audio/Part3.mp3" type="audio/mpeg">
        브라우저가 오디오 태그를 지원하지 않습니다.
      </audio>
    </div>

    <p style="color:#989898; margin-bottom: 60px;">
      “한”은 결국 극에 다다랐다. 혼자서는 더 이상 나아갈 수 없는 상황에 처하게 된 이들의 마음에 응어리가 진다. 괴로워하지만 발버둥칠 수록 엉켜버릴 뿐이다. 누군가의 손길이 필요한 때. 하나의 손은 점차
      여러명의 도움으로 번지고, “살풀이”로 한이 해소되어 간다. 사회에는 점차 “정”이 퍼져나가며 따뜻한 색감을 더한다.
    </p>



    <div class="artwork-item">
      <div class="artwork-media">
        <div id="canvas-7" class="canvas-container"></div>
      </div>
      <div class="artwork-desc">
        <div class="code-container" onclick="toggleCode(this)">
          <div class="code-header">
            <span class="code-title">p5.js code</span>
            <span class="toggle-icon">▼</span>
          </div>
          <div class="code-body">
            <pre>
// 3-1 벽면
// 참고: http://openprocessing.org/sketch/2044657/
// Shader Park API: https://docs.shaderpark.com/references-js/

let sdf;
function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL); // 1112, 834
	pixelDensity(1); // increase for higher quality, decrease for speed
	
	sdf = createShaderPark(shaderParkCode, {
		scale: 0.8, // reduce this value if your scene is cut off at the edges
		drawGeometry: () => sphere(170) // increase this value to enlarge the scene
	});
}
function draw() {
  //clear();
	background(255);
	noStroke();
	orbitControl();
	translate(0,-50, 0);
	scale(3);
	push();
  sdf.draw();
}

function shaderParkCode() {
  let p = enable2D();
  p = vec2(p.x, p.y);

  let radians = 0.017453292519943295; 
  const zoom = 40; 
  const brightness = 0.975;
  let fScale =  1.25;

  function cosRange (degrees, range, minimum){
	  return (((1.0 + cos(degrees * radians)) * 0.5) * range) + minimum;
  }

  let t = time ;
  let uv = vec2(p.x, p.y);
  let ct = cosRange(t*5.0, 3.0, 1.1);
  let xBoost = cosRange(t*0.2, 5.0, 5.0);
  let yBoost = cosRange(t*0.1, 10.0, 5.0);
  fScale = cosRange(t * 15.5, 1.25, 0.5);

  for(let i=1; i < zoom; i++) {
        let _i = 1.0*i;
		let newp = p; 
		newp.x+=0.25/_i*sin(_i*p.y+t*cos(ct)*0.5/20.0+0.005*_i)*fScale+xBoost;		
		newp.y+=0.25/_i*sin(_i*p.x+t*ct*0.3/40.0+0.03*i+15)*fScale+yBoost;
		p = newp;
  }
	
  let newColor = vec3(0.5*sin(3.0*p.x)+0.5,0.5*sin(3.0*p.y)+0.5,sin(p.x+p.y));
  newColor *= brightness;

    let vigAmt = 5.0;
    let vignette = (1.-vigAmt*(uv.y-.5)*(uv.y-.5))*(1.-vigAmt*(uv.x-.5)*(uv.x-.5));
	  let extrusion = (newColor.x + newColor.y + newColor.z) / 4.0;
    extrusion *= 1.5;
    extrusion *= vignette;

  color(newColor);
}
</pre>
          </div>
        </div>
      </div>
    </div>


    <div class="audio-wrapper" style="margin-top: 60px; padding-top: 60px; border-top: 1px solid #333;">
      <audio controls controlsList="nodownload" oncontextmenu="return false" class="custom-audio">
        <source src="Assets/audio/Part4.mp3" type="audio/mpeg">
        브라우저가 오디오 태그를 지원하지 않습니다.
      </audio>
    </div>

    <p style="margin-bottom: 60px;">
      “정”을 되찾은 사회는 점차 생기를 얻는다. 사람들의 가슴 속에는 점차 잊고있던 “흥”겨움이 꿈틀거리기 시작한다. “흥”은 점점 서로에게 물들어가고 모두 함께 신명나게 춤을 추며 비로소 각자의 개성을
      드러낸다. 정갈하게 정리되어 있던 사회의 질서가 깨어지며 난장이 벌어지지만, 사람들의 얼굴에는 웃음이 만개한다.
    </p>

    <div class="artwork-item">
      <div class="artwork-media">
        <div id="canvas-8" class="canvas-container"></div>
      </div>
      <div class="artwork-desc">
        <div class="code-container" onclick="toggleCode(this)">
          <div class="code-header">
            <span class="code-title">p5.js code</span>
            <span class="toggle-icon">▼</span>
          </div>
          <div class="code-body">
            <pre>
// 4-1 벽면
// 마이크 입력 음량에 따라 원이 생성됩니다.

let mic;
let circles = [];

function setup() {
  createCanvas(windowWidth, windowHeight);
  mic = new p5.AudioIn();
  mic.start();
  noStroke();
}

function draw() {
  background(255);

  let vol = mic.getLevel();

  // Adjust the circle creation probability based on the microphone volume
  let probability = map(vol, 0, 1, 0, 1); // 조절 가능한 범위

  // Adjust the number of circles created based on the microphone volume
  let numCircles = floor(map(vol, 0, 1, 1, 10));

  for (let j = 0; j < numCircles; j++) {
    if (random() < probability) {
      let x = random(width);
      let y = random(height);
      let d = random(100, 200);
      let growth = random(2, 5);
      let alpha = 100; // 시작 투명도
      let fillColor = color(random(255), random(255), random(255));

      circles.push({ x, y, diameter: d, growth, alpha, fillColor });
    }
  }

  // Draw circles
  for (let i = 0; i < circles.length; i++) {
    let circle = circles[i];
    circle.diameter += circle.growth;

    // 투명도가 100에서 시작하여 0 미만으로 내려가지 않도록 조정
    circle.alpha = constrain(circle.alpha - 2, 0, 100);

    fill(circle.fillColor.levels[0], circle.fillColor.levels[1], circle.fillColor.levels[2], circle.alpha);
    ellipse(circle.x, circle.y, circle.diameter, circle.diameter);

    // Remove circles when they fade out
    if (circle.alpha <= 0) {
      circles.splice(i, 1);
      i--;
    }
  }
}
</pre>
          </div>
        </div>
      </div>
    </div>



    <div class="artwork-item">
      <div class="artwork-media">
        <div id="canvas-9" class="canvas-container"></div>
      </div>
      <div class="artwork-desc">
        <div class="code-container" onclick="toggleCode(this)">
          <div class="code-header">
            <span class="code-title">p5.js code</span>
            <span class="toggle-icon">▼</span>
          </div>
          <div class="code-body">
            <pre>
// 4-2 벽면
// 마이크 입력 음량에 따라 파티클 크기가 변합니다
// 글자를 클릭하면 파티클이 퍼지는 효과를 볼 수 있습니다
// 참고 : https://openprocessing.org/sketch/1564310

let canvas;
let message = '흥'; // 텍스트 메시지
let font;
let fontFile = "NanumGothic.ttf"; // 사용할 폰트 파일
let fontSize = 85; // 텍스트 스캔용 기본 크기 (변경 불필요)

let textData = []; // 텍스트의 픽셀 데이터를 저장할 배열
let dotsCoordinate = []; // 텍스트의 좌표를 저장할 배열
let particles = []; // 파티클 객체를 저장할 배열
let scaleRate; // 파티클의 크기를 조절하는 비율 (동적으로 변경됨)

let inpactRange = 120; // 마우스 입력에 대한 파티클의 영향 범위
let isMousePressed = false; // 마우스 클릭 여부를 저장하는 변수
let mic; // 마이크 입력 객체

function preload() {
  font = loadFont(fontFile); // 폰트 파일 불러오기
}

// 파티클 클래스
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 2; // 반지름
    this.originalX = x; // 원래 x 좌표
    this.originalY = y; // 원래 y 좌표
    this.colors = ["#A71C1C", "#A71C1C", "#A71C1C",
                   "#032A53", "#032A53", "#032A53",
                   "#e5e1dc", "#e5e1dc",
                   "#70B18D", "#33614A", "#f3a712"]; // 색조합 지정
    this.color = random(this.colors); // 색상 랜덤 선택
    this.density = random(30) + 10; // 파티클 밀도 (랜덤)
    this.amplitude = random(40) + 10; // 파티클 크기 (랜덤)
  }

  draw() {
    let particleSize = this.r + this.amplitude * (3 * mic.getLevel()); // 파티클 크기 계산
    fill(this.color); // 파티클 색상 설정
    circle(this.x, this.y, particleSize * 2); // 파티클 그리기
  }

  update() {
    let distanceFromMouse = Math.sqrt((this.x - mouseX) ** 2 + (this.y - mouseY) ** 2); 
    // 마우스와의 거리 계산
    let distanceToOrigin = Math.sqrt((this.originalX - this.x) ** 2 + (this.originalY - this.y) ** 2); 
    // 원래 위치와의 거리 계산

    if (isMousePressed) { // 마우스 클릭 중일 경우
      if (distanceFromMouse < inpactRange) {
        let repulsionAngle = Math.atan2(this.y - mouseY, this.x - mouseX); // 반발력의 각도 계산
        let repulsionForce = (inpactRange - distanceFromMouse) / inpactRange * this.density; 
        // 반발력의 크기 계산
        this.x += Math.cos(repulsionAngle) * repulsionForce; // 파티클 위치 갱신
        this.y += Math.sin(repulsionAngle) * repulsionForce;
      }
    } 
    
    else { // 마우스 클릭 중이 아닌 경우
      let attractionAngle = Math.atan2(this.originalY - this.y, this.originalX - this.x); 
      // 인력의 각도 계산
      let attractionForce = Math.abs(distanceToOrigin) / this.density; // 인력의 크기 계산
      this.x += Math.cos(attractionAngle) * attractionForce; // 파티클 위치 갱신
      this.y += Math.sin(attractionAngle) * attractionForce;
    }
  }
}

function setup() {
  canvas = createCanvas(windowWidth, windowHeight);
  colorMode(HSL);
  noStroke();
  mic = new p5.AudioIn();
  mic.start();
  initSystem();
  canvas.mousePressed(handleMousePressed);
  canvas.mouseReleased(handleMouseReleased);
}

function draw() {
  background(255);
  updating(); // 파티클 업데이트
  drawParticles(); // 파티클 그리기
}

// 윈도우 크기가 바뀌면 자동으로 호출되는 함수
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  initSystem(); // 파티클 위치와 크기 재계산
}

// 시스템 초기화 및 파티클 재배치 함수
function initSystem() {
  background(255);
  textSize(fontSize);
  textFont(font);
  textAlign(LEFT, TOP);

  // 1. 텍스트 데이터 분석
  textData = getTextData(message); 
  dotsCoordinate = getCoordinates(); 

  // 2. 화면 크기에 맞춰 스케일과 위치 계산
  let txtW = textWidth(message); // 원본 텍스트 너비
  let txtH = textAscent() + textDescent(); // 원본 텍스트 높이
  
  // 화면 너비의 60% 정도를 차지하도록 scaleRate 계산
  let targetWidth = windowWidth * 0.6; 
  scaleRate = targetWidth / txtW;

  // 파티클로 만들어질 전체 텍스트의 실제 크기 계산
  let particleTextWidth = txtW * scaleRate;
  let particleTextHeight = txtH * scaleRate;

  // 화면 중앙에 오도록 시작점 계산
  let marginX = (windowWidth - particleTextWidth) / 2;
  let marginY = (windowHeight - particleTextHeight) / 2;

  // 3. 파티클 생성
  particles = createParticles(scaleRate, marginX, marginY);
}


// 텍스트의 픽셀 데이터를 가져오는 함수
function getTextData(message) {
  let data = [];
  let ascent = textAscent();
  let descent = textDescent();
  background(255);
  fill(0);
  text(message, 0, 0);
  
  for (let y = 0; y < ascent + descent; y++) {
    let row = [];
    for (let x = 0; x < textWidth(message); x++) {
      row.push(canvas.get(x, y));
    }
    data.push(row);
  }
  return data;
}

// 텍스트의 좌표를 가져오는 함수
function getCoordinates() {
  let coordinate = [];
  for (let y = 0; y < textData.length; y++) {
    let row = [];
    for (let x = 0; x < textData[0].length; x++) {
      let redVal = textData[y][x][0];
      if (redVal < 128) {
        row.push(1);
      } else {
        row.push(0);
      }
    }
    coordinate.push(row);
  }
  return coordinate;
}

// 텍스트의 좌표를 기반으로 파티클을 생성하고, 위치와 속성을 설정하여 배열에 저장하여 반환
function createParticles(scaleRate, marginX, marginY) {
  let newParticles = [];
  for (let y = 0; y < dotsCoordinate.length; y++) {
    for (let x = 0; x < dotsCoordinate[0].length; x++) {
      if (dotsCoordinate[y][x] === 1) {
        let posX = x * scaleRate + marginX;
        let posY = y * scaleRate + marginY;
        newParticles.push(new Particle(posX, posY));
      }
    }
  }
  return newParticles;
}

// 파티클 배열을 순회하면서 각 파티클을 그림
function drawParticles() {
  for (let i = 0; i < particles.length; i++) {
    particles[i].draw();
  }
}

// 파티클 배열을 순회하면서 각 파티클의 위치를 업데이트
function updating() {
  for (let i = 0; i < particles.length; i++) {
    particles[i].update();
  }
}

// 마우스 클릭 여부에 따라 isMousePressed 변수를 다르게 설정
function handleMousePressed() {
  isMousePressed = true;
}
function handleMouseReleased() {
  isMousePressed = false;
}

function keyPressed() {
  inpactRange += 10;
}
</pre>
          </div>
        </div>
      </div>
    </div>


  </main>


  <footer class="footer">
    <div class="footer-left">
      <img src="Assets/images/logo.svg" alt="느루" class="footer-logo">
      <p>한꺼번에 몰아치지 아니하고 오래도록.</p>
      <a href="https://www.instagram.com/neuru_scg/" target="_blank" class="sns-link">
        <img src="Assets/images/instagram.svg" alt="인스타그램" class="sns-icon-img">
      </a>
    </div>
    <div class="footer-right">
      <div class="footer-col">
        <h4>팀 느루</h4>
        <ul>
          <li>김성준</li>
          <li>서리라</li>
          <li>이서연</li>
          <li>천사은</li>
          <li>한수민</li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>협력</h4>
        <ul>
          <li>김단</li>
          <li>박규리</li>
          <li>서민주</li>
          <li>임지우</li>
          <li>정지혜</li>
          <li>홍승주</li>
        </ul>
      </div>
      <div class="footer-col">
        <h4>웹 개발</h4>
        <ul>
          <li>천사은</li>
        </ul>
      </div>
    </div>
  </footer>
</body>

</html>